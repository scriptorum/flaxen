#Flaxen
##Overview
> You've got Haxepunk in my Ash! You got Ash in my Haxepunk!

Flaxen is a Haxe 3 project that combines [HaxePunk](https://github.com/HaxePunk/HaxePunk) (a game engine) with [Ash-Haxe](https://github.com/nadako/Ash-HaXe) (an entity component system or ECS). Flaxen wraps a HaxePunk engine and provides an interface to manipulate Ash entities. Add some built-in components, and HaxePunk objects  maaaaaaagically appear on the screen. This is due to the (also built-in) nodes and systems that map these Ash entities to their HaxePunk counterparts, behind-the-scenes. With Ash, you get a full ECS, instilling complex game behaviors and interaction by building your own systems and components.

Flaxen started as base code I just used for game jams. Pardon the dust as I try to make this project more useful to others.  Most of this I typed up without testing it, so that makes me a rotten person.

###Ash
In a typical ECS, you create entities to represent any kind of game object, whether they are on-screen elements or any state data you'd like to manipulate. To make the entities do things, first you add components to the entities. Components are simple objects that define the characteristics of the entity they belong to. Then you build systems, which observe changes in these components and respond appropriately. Rather than looking through all entities, Ash uses "nodes" to ensure a system only acts upon entities that match its criteria. 

A common example is movement. Give an entity Position and Velocity components. Create a MovementNode referencing both of those. Then add a MovementSystem that looks through all matching entities, updating each Position component based on the values of the Velocity component. For more information about ECS and Ash in particular, here's a [good overview](http://www.richardlord.net/blog/why-use-an-entity-framework) by Richard Lord, the author of original Ash. Ash-Haxe is a Haxe port.

###HaxePunk
HaxePunk is a game library that provides a number of useful constructs. It can be used on its own, separate from Flaxen; visit the [HaxePunk website](http://HaxePunk.com). You don't need to know HaxePunk to use many parts of Flaxen, but it is *super duper* helpful. Flaxen provides built-in components that abstract access to Image, Text, Backdrop, Emitter, Tilemap and Spritemap. Additional HaxePunk objects are available that Flaxen does not support. HaxePunk is a really great library and if you want cross-platform game development but don't care about a full entity component system, just skip Flaxen and use ([HaxePunk](https://github.com/HaxePunk/HaxePunk)) directly. I won't be mad. Seriously.

##Install Flaxen
Sorry, Flaxen is not currently in the haxelib library! To install it from github:

```bash
haxelib git flaxen https://github.com/scriptorum/flaxen
```

It requires Haxe 3 and has dependencies on [OpenFL](http://www.openfl.org/documentation/getting-started/installing-openfl/), [HaxePunk](https://github.com/HaxePunk/HaxePunk) and [Ash-Haxe](https://github.com/nadako/Ash-HaXe). These depencies must be installed for Flaxen to compile. The last time I installed them I had to do the following magickery which may be out of date:

```bash
haxelib install openfl
haxelib run openfl setup
haxelib install HaxePunk
haxelib run HaxePunk setup
haxelib install ash
```

##Flaxen Fundamentals

###Create Flaxen
Subclassing Flaxen is the recommended method to initialize it.

```haxe
class MyFlaxenApp extends Flaxen
{
	public static function main()
	{
		new MyFlaxenApp();
	}

	override public function ready()
	{
		// Setup here...
		var e:Entity = newSingleton("player"); ...
	}
}
```

In the ready() method is where you add systems, create entities, and populate entities with components.

You may override the constructor to provide custom Flaxen settings. It's also *possible* to intialize Flaxen without subclassing, but then Flaxen does not wait for HaxePunk to initialize the scene, which may have repercussions. Ye be warned! 

```haxe
var f = new Flaxen();
var e:Entity = f.newSingleton("player");
```

###Accessing Ash

The ash [engine](https://github.com/nadako/Ash-HaXe/blob/master/src/ash/core/Engine.hx) contains all your entities and systems. You can access it directly from Flaxen at any time.

```haxe
ash.entityAdded.add(myAshEntityAddedHandler); // get notified when an entitiy is added
```

###Entities

First, you need some entities! You can create a new, named entity with newSingleton. This entity will be added to Ash.

```haxe
newSingleton("mySingleton");
```

When you don't care about the name, use newEntity, which optionally accepts a string to prefix the autogenerated name. (Prefixes just make it easier to debug.)

```haxe
var e1 = newEntity();
var e2 = newEntity("obj"); // e.g., returns entity named obj1 
```

You can retrieve a named entity in a few ways:

```haxe
e = getEntity("moon"); // returns entity if found or null
e = demandEntity("moon"); // returns entity if found or logs error
e = resolveEntity("moon"); // returns entity, if not found creates it
```

And entities can be removed three ways. Here's two of them. (I didn't feel like typing why the third way is a bad idea, and instead I spent the time typing this.)

```haxe
removeEntity("moon"); // returns true if removed, false if not found
demandRemoveEntity("moon"); // log error if not found, otherwise remove
```

###Components

Components are constructed like any object, and are added to entities. Ash entities also support adding components to them after creation with chaining:

```haxe
var e = newEntity()
	.add(new Hair(Color.SALTNPEPPA)) // newly created component
	.add(BadBack.instance); // cached component singleton
var middleAge = new Age(45);
e.add(middleAge);
```

You can get components from entities a number of ways:

```haxe
var c1 = e.get(Hair); // Gets component or returns null
var c2 = getComponent("eric", BadBack); // Find entity and component therein, or return null
var c3 = demandComponent("eric", Age); // Find entity and component therein, or throw error 
```

Components are removed from entities through the Ash [entity](https://github.com/nadako/Ash-HaXe/blob/master/src/ash/core/Entity.hx): 

```haxe
e.remove(BadBack); // I'm cured!
```

Flaxen comes with many useful components, but you'll want to add your own to the mix. At its core, a component is simply an object with public data fields, and a constructor. Let's say you wanted a component to track the player, monster, or NPC health. This component has only one field in it, so it's just called *value*:

```haxe
class Health
{
    public var value:Int;
    public function new(value:Int)
    {
        this.value = value;
    }
}
```

Sometimes a component doesn't need to contain any data, its mere presence is helpful enough as a marker. To make such components, you can use a StaticComponent. Extending this class will give you a constructor and a static variable called instance.

```haxe
class IsCorpse extends StaticComponent
{
}
```

You can add your components to any entity, and modify them just like any pre-built component:

```haxe
e1.add(new Health(100));

var health = e2.get(Health);
health.value = 50;

e3.add(IsCorpse.instance);
```

###Systems and Nodes

When you initialize Flaxen, it adds a set of pre-built systems to Ash. There are additional pre-built systems you can add. Once added, the update function in each of these systems will run in a loop, processing entities and responding appropriately.

* ModeSystem
* UpdateSystem
* ActionSystem
* TweeningSystem
* RenderingSystem
* AudioSystem

 To add a system is pretty durn simple. 

```haxe
addSystem(MySystem);
```

Systems are processed in the order they are added.

Build your own systems and nodes to handle game logic. Let's say you wanted to check if any entities have recently died.

```haxe
class DeathSystem extends System
{
    public function new(f:Flaxen) // Access flaxen through "f"
    { 
        super(f); 
    }

    override public function update(time:Float)
    {
        for(node in ash.getNodeList(HealthNode))
        {
            if(node.health.value <= 0)
            {
            	var e = node.entity;
            	e.remove(Health);
            	e.add(IsCorpse.instance);
            	f.newSound("gasp-ack-dying.wav");
            }
        }
    }
}
```

Systems employ a speedy filtering mechanism called Nodes to get at just the entities that apply to them.

```haxe
class HealthNode extends Node<HealthNode>
{
    public var health:Health;
}
```

Only entities with a health component will be returned by getNodeList(). In this case we only have one component we're looking for, but you could specify multiple components, and they would all have to be present in the entity for getNodeList to include it. Ignore the fact that it looks weird having a class extend a typed version of itself, that's a strange Ash-ism but it works. Just effin weird. Super weird.

## Integration With HaxePunk

###Showing an Image
To put up a simple HaxePunk [Image](http://haxepunk.com/documentation/api/com/haxepunk/graphics/Image.html), you need to add Image and Position components to the entity. Here's one, which is centered on the screen:

```haxe
var e:Entity = newEntity()
	.add(new Image("art/flaxen.png"))
	.add(Position.center())
	.add(Offset.center());
```

An image is normally placed with the upper-left corner matching the position. In this case, the entity is given a center offset, which the RenderingSystem takes into account when drawing the Image. Offset is an optional component.

To show part of an image, say a sprite on a sprite sheet, you could add a [clipping region](http://haxepunk.com/documentation/api/com/haxepunk/graphics/Image.html#new) to the image:

```haxe
var image = new Image("art/flaxen.png", new Rectangle(0,0,50,50));
e.add(image);
```

Or you could define an ImageGrid and specify a Tile. An ImageGrid represents the size of an individual tile in pixels. The number of tiles across and down are calculated at run-time based on the image dimensions. The Tile tells us which tile to use, with 0 the tile in the upper left, 1 the next tile to the right, and so on.

Yes, ImageGrid should really be called TileSize or something. Don't you think I know it's poorly named? I'm the one who named it! Hmph! Uh ... where was I? Oh yes:

```haxe
var e:Entity = newEntity()
	.add(new Image("art/tiles.png"))
	.add(Position.center())
	.add(Offset.center())
	.add(new ImageGrid(50, 50))
	.add(new Tile(0));
```

###Showing a Grid of Images

Under the hood, we use a HaxePunk [Tilemap](http://haxepunk.com/documentation/api/com/haxepunk/graphics/Tilemap.html) to show a rectangular grid with each tile containing an image. This usage requires Image, Position, ImageGrid, and Grid components. *Don't get me started on ImageGrid again.* 

Grid is a general purpose 2D array of Ints that corresponds to the tile numbers you want to show at any given tile position. For example, if you have four tiles in tiles.png and want to show a 3x3 grid of tiles, this might very well do that:

```haxe
var e:Entity = newEntity()
	.add(new Image("art/tiles.png"))
	.add(Position.topLeft());
	.add(new ImageGrid(50, 50));
var grid = new Grid(3, 3);
grid.load("1,3,1;2,0,2;1,3,1");
e.add(grid);
```

Such high confidence.

###Playing an Animation

A HaxePunk [Spritemap](http://haxepunk.com/documentation/api/com/haxepunk/graphics/Spritemap.html) will be created if you put together an entity with Image, Position, ImageGrid, and Animation components.

Animations can be looped. In this instance, the animation plays forwards and backwards. After the animation completes, the the entity holding it is removed from Ash.

```haxe
var anim = new Animation("2,4-7,9", 30, LoopType.Both);
anim.destroyEntity = true; // when animation completes
var e:Entity = new Entity()
	.add(new Image("art/anim.png"))
	.add(Position.zero())
	.add(new ImageGrid(50, 50));
	.add(anim);
```

###Repeating an Image Over the Screen

In HaxePunk this is a [Backdrop](http://haxepunk.com/documentation/api/com/haxepunk/graphics/Backdrop.html) object that covers the whole screen, tiling the same image. It requires Image and Repeating components. Since Repeating has no data, it is defined as a static singleton component.

```haxe
var e:Entity = newEntity()
	.add(new Image("art/tiles.png"))
	.add(Repeating.instance);
```


###Adding Text

For TrueType [Text](http://haxepunk.com/documentation/api/com/haxepunk/graphics/Text.html), you need Position and Text components. By default, it will use the [default HaxePunk font](http://haxepunk.com/documentation/api/com/haxepunk/HXP.html#defaultFont).

```haxe
var textEntity:Entity = newEntity()
	.add(new Position(10,10))
	.add(new Text("I have something to say"));
```

This could be styled using a TextStyle object. Style options include word wrapping, justification, an optional drop shadow, etc.

```haxe
var style = TextStyle.createTTF(0xFFFF00, 40, "myfont.ttf", Center);
textEntity.add(style);
```

Flaxen has its own bitmapped text. This requires an additional Image component, and can also be styled with a TextStyle:

```haxe
var e:Entity = new Entity()
	.add(new Image("art/myfont.png"))
	.add(Size.screen().scale(.8)) // resize to 80% of screen size for no good reason
	.add(Position.center())
	.add(new Text("I have nothing to say"))
	.add(TextStyle.createBitmap(true, Center, Center, -4, -2));
```

Note that a bitmap font image must contain the characters of the BitmapText.ASCII_CHAR_SET, from left to right, with a clean and non-overlapping gap between letters. It will scan the character widths when the font is first used. You can also supply an alternate character set, to specify which characters are in the image. 

The folowing gives a numeric character set, and defines the width of the space to be equal one-third the width of the "2" character. Normally, a character set uses the "M" as a space guide, but this set lacks the "M," so pthbth...

```haxe
TextStyle.createBitmap(false, Right, Top, 0, -2, 0, "2", false, "0123456789")
```

###Adding a Particle Emitter

The particle system is based off of HaxePunk's [Emitter](http://haxepunk.com/documentation/api/com/haxepunk/graphics/Emitter.html). It requires Position and Emitter components. Emitter is unusual in that it does not use an Image, but rather the path to the image asset is supplied to the Emitter object itself. Anyhow here's a puff of smoke effect:

```haxe
var emitter = new Emitter("art/particle-smoke.png");
emitter.destroyEntity = true;
emitter.maxParticles = Math.floor(radius * radius / 15);
emitter.lifespan = 1.0;
emitter.lifespanRand = 0.1;
emitter.distance = radius * 1.5;
emitter.rotationRand = new Rotation(360);
emitter.stopAfterSeconds = 0.3;
emitter.emitRadiusRand = radius / 10;
emitter.alphaStart = 0.2;

newSingleton("emitter")
	.add(Position.center())
	.add(emitter);
```

###Layers

HaxePunk organizes its visual elements onto [layers](http://haxepunk.com/documentation/api/com/haxepunk/Entity.html#layer), so you can put things in front or behind other things. Exciting. To alter the default layer (0), add a Layer component to your entity.

```haxe
var e:Entity = newEntity()
	.add(new Image("art/flaxen.png"))
	.add(Position.topLeft())
	.add(new Layer(5));
```

###Working the Camera

You can move the camera directly in HaxePunk, by simply altering [HXP.camera](http://haxepunk.com/documentation/api/com/haxepunk/HXP.html#camera). 

```haxe
HXP.setCamera(10, 10);
```

For smoother camera movement, employ the CameraService:

```haxe
CameraService.animCameraTo(10, 10, 1.0); // one second camera movement
```

Entities have a default scroll factor of 0, which means these objects move with the camera (such as a HUD element). To create a parallax effect when you move the camera, you can add a ScrollFactor component, which affects the Graphic's [scrollx](http://haxepunk.com/documentation/api/com/haxepunk/Graphic.html#scrollX)/[scrolly](http://haxepunk.com/documentation/api/com/haxepunk/Graphic.html#scrolly) attributes. This entity will move 50 pixels for every 100 pixels the camera moves:

```haxe
e.add(new ScrollFactor(0.5, 0.5));
```

To have the camera follow an entity as it moves, add the built-in CameraSystem:

```haxe
addSystem(new CameraSystem());
changeCameraFocus(e);
```

##Image Manipulations

Most [Image](http://haxepunk.com/documentation/api/com/haxepunk/graphics/Image.html)-based entities (not Emitter) can have optional components added to them that affect their appearance:

###Scale

Changes the horizontal and vertical scaling of the image by a percentage. 1.0 is full size, 0.5 is half size, 2.0 is twice the size, etc.

```haxe
e.add(new Scale(0.1, 10.0)); // One-tenth the width, but ten times the height
e.add(Scale.half()); // Half the width
```

###Rotation

You can [rotate](http://haxepunk.com/documentation/api/com/haxepunk/graphics/Image.html#angle) an entity by adding a Rotation component. This is in degrees, from 0 to 360. Because we're programmers, not mathemeticians, gurshdurnit!

```haxe
e.add(new Rotation(90)); // quarter right turn
e.add(Rotation.random()); // What what what?!
```

###Offset

Images are drawn with the upper-left corner of the image aligning with the entity position. To change this [alignment point](http://haxepunk.com/documentation/api/com/haxepunk/Graphic.html#x) add an Offset component, which will be added to the final position.

For example, to center an image:

```haxe
e1.add(new Offset(-10,-10)); // moves image up/left 10 pixels, so a 20x020 image appears centered at the Position

e2.add(Offset.center()); // shorthand for above, but works with any image size
e2.add(new Position(50,50)); // Image is centered over 50,50

e3.add(new Offset(-1,0,true)); // as percentage; image is top/right-aligned
```

###Origin

The [origin](http://haxepunk.com/documentation/api/com/haxepunk/Entity.html#originX) is the transformation point for the entity. Rotation and scaling apply to this origin point. Unlike in HaxePunk which applies an offset whenever the origin is altered, Flaxen origin is kept distinct from its offset. I don't know, it just bugged me that the two were tied together, so I changed it, violently and without remorse.

Let's say you had a picture of your brother winking, and you wanted to rotate the image about his other eye which is open. Let's further say the open eye, relative to the size of the image, is at a position 50% to the right and 25% down:

```haxe
e.add(new Image("mybrothertheidiot.png"));
e.add(Position.center());
e.add(Offset.center());
e.add(new Origin(.5,.25,true));
```

Or if you know the image dimensions and want to specific the exact pixel position of the eye:

```haxe
e.add(new Origin(50,25)); // with a 100x100 image
```

###Size

Size is an alternate way to scale the image by specifying the precise image dimensions you desire.

```haxe
var size = new Size(100,200)
e1.add(size);
size.scale(0.50) // Change to 50x100

e2.add(Size.screen()); // Match screen dimensions
```

###Alpha

The Alpha component lets you change the level of opacity of the image. You know, the transparency, opacity, translucency, see-thru-itude. Also called [alpha](http://haxepunk.com/documentation/api/com/haxepunk/graphics/Image.html#alpha).

```haxe
e1.add(new Alpha(.1)); // Very transparent
e2.add(Alpha.clear()); // Totally transparent
e3.add(Alpha.opaque()); // Solid. AS A ROCK! That's what my love is... what, nobody remembers Ashford and Simpson?
e4.add(Alpha.half()); // 50% alpha
```

###Invisible

Unlike Alpha(0), this component indicates the entity should not be rendered at all. It's not [visible](http://haxepunk.com/documentation/api/com/haxepunk/Entity.html#visible).

```haxe
e.add(Invisible.instance);
```

##Other Useful Things

###ActionQueue
The ActionQueue lets you chain events, add and remove components/entities, wait for components to reach a certain state, do timed delays, and make callbacks to your functions. I like. Scotchy scotch scotch. ActionQueue is a component. It must be added to an entity to be processed. Here's a basic action queue that waits for a sound to complete before removing an entity. 

```haxe
var aq = newActionQueue() // makes entity which it destroys when queue finishes
    .waitForProperty(deathSound, "complete", true) // wait for sound to finish
    .removeEntity(dyingMonster);
```

The method newActionQueue creates a new entity to put the ActionQueue into. It also marks the queue as destroyEntity, so it will destroy the containing entity when it completes.

You can also make an action queue manually, which is helpful in several cases.

```haxe
var aq1 = new ActionQueue()
    .delay(1.0) // wait 1 second
    .addCallback(myFunc); // call myFunc after 1 second
var e = new Entity()
    .add(aq1);
fuction myFunc(): Void
{
    e.remove(aq1);
    // ... repurpose entity
}
```

See [ActionQueue.hx](https://github.com/scriptorum/flaxen/blob/master/source/flaxen/component/ActionQueue.hx) for a full list of commands.

##Undocumented Features
Well I still got a bunch of features to document.

* The mode system lets you specify different start/stop and input handlers based on your game mode (scene), mark entities as transitional, and do a few other funky things. 
* Flaxen has its own Tween component for interpolating values, but you can still use HaxePunk's tweener if you want.
* Sounds can be managed through a Sound component.
* Dependency relationships between entities can be defined in order to remove dependents as a group.
* A layout manager for help switching between mobile orientations.
* ComponentSets for pre-defining entity transformations and invoking them at runtime.
* And moaaar stuff that barely works!

## For More Help
Some simple demos are included. Flaxen has changed a lot, but you can look at my [Ludum Dare](http://ludumdare.com/compo/author/scriptorum/) compo entries with source on [GitHub](https://github.com/scriptorum) for a few more examples. This is a work in progress and you should expect it to continue to evolve and break code.

##Dependencies
Flaxen would not be possible without the work of these awesome projects:
* [HaxePunk](https://github.com/HaxePunk/HaxePunk) 
* [Ash-Haxe](https://github.com/nadako/Ash-HaXe)
* [OpenFL](http://www.openfl.org/)
* [Haxe](http://haxe.org)

##The MIT License (MIT)

Copyright (c) 2014 Eric Lund

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
